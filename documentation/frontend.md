# Enwida Charts Frontend Documentation

## Location
The charts frontend code is located within the web resources of the Spring web project:

``$ENWIDA_WEB_ROOT/src/main/webapp/resources``

The chart-specific CSS files can be found in the subdirectory

``css/chart``

whereas the CoffeeScript/JavaScript sources live in the

``js/chart``

subdirectory.

## Tools / Libraries
As our implementation relies on 3rd party libraries and frameworks, we try separate these so-called
"assets" from the actual charts frontend.
So any HTML document which contains charts has to include the following files:

- resources/css/chart/assets.css
- resources/css/chart/chart.css
- resources/js/chart/assets.js
- resources/js/chart/chart.js

[TODO: Only one css/js file in production (complicates development, though)]

### CSS
In order to minify the CSS assets (bootstrap, datepicker, etc.) we use the tool `cleancss`.
When adding or removing CSS assets, please edit the `Makefile` in the `css/chart` directory to
reflect the changes. A new `assets.css` file can be generated by executing the `make` command in
this directory. It will minify the source CSS assets (usually located in the `assets` subdirectory)
given in the `Makefile` to a file called `assets.css`.

### JavaScript
We use `uglifyjs` to minify JavaScript sources/assets like jquery or bootstrap. The
assets compilation is handled by the `Makefile` located in the `js/chart` subdirectory. In order to
only compile the JavaScript assets to a single `assets.js` file please invoke the command
`make compile_assets`.

We don't write plain JavaScript for our charts frontend logic but use the cleaner and more concise
[CoffeeScript](http://coffeescript.org) which "compiles" down to JavaScript.
In order to provide a modular design for the charts implementation, we additionally use 
[require.js](http://requirejs.org) for this matter.
The compilation of the JavaScript sources thus involves the following steps:

- Minify the JavaScript assets
- Compile all .coffee files to their respective .js equivalent
- Minify the compiled require.js modules into one file

All of them are accomplished at once by invoking the `make` command.

During the development process it is often convenient to skip the last step because debugging
minified JavaScript code isn't fun at all.
To achieve this, you can invoke `make dev` instead of the parameter-less variant.
Note that this does _not_ mean you will have to include every single .js file in your HTML
document as the loading of the modules is managed by the `require.js` library.
You can even automatically compile every .coffee file into a .js file as soon as it changes by
executing the command `coffee -wc .` in the `js/chart` directory.

### Requirements Installation
While the previous section was about why we need all these 3rd party tools, this section shows how
these requirements can be installed.

- Install [node.js](http://nodejs.org) (including the `npm` command-line tool)
- Install the `make` command (should be preinstalled on all *nix systems, use
[cygwin](http://www.cygwin.com) or
[GnuWin32](http://gnuwin32.sourceforge.net/packages/make.htm) for Windows)
- Install the remaining requirements: `npm install -g coffee-script clean-css uglify-js requirejs`

[TODO: Test if these steps work for Windows ;)]

### Quick CoffeeScript / RequireJS / Flight Walkthrough
This walkthrough will only contain very basic explanation to get you started. Please refer to the
corresponding websites ([coffeescript.org](http://coffeescript.org),
[requirejs.org](http://requirejs.org), [twitter.github.io/flight](http://twitter.github.io/flight)) for more detailed introductions, tutorials and documentation.

#### CoffeeScript
The CoffeeScript syntax is very similar to the JavaScript syntax but I will try to point our the
most important differences here.

##### Semicolons
Semicolons are not necessary in CoffeeScript. Don't use them.

##### Assignments
The JavaScript expression `name = "John"` assigns the string "John" to the _global_ variable `name`.
In general this is considered bad style because it is very easy to pollute the global namespace
this way. Instead we have to write `var name = "John"` in order to create a _local_ variable.
CoffeeScript makes it really difficult to accidentally assign to a global variable. So every
assignment of the form `name = "John"` is translated to use a local "name" variable. The `var`
keyword is forbidden and its usage will throw a compiler error. If you _really_ want to assign
to a global variable, you have to assign to the `window` object explicitly: `window.name = "John"`

tl;dr: `name = "John"` is an assignment in CoffeeScript which uses local variables.

##### Functions
The CoffeeScript expression

``(name, age) -> console.log name + " is " age + " years old"``

translates to the following JavaScript:

``function(name, age) { console.log(name + " is " + age + " years old"); }``

As you can see, the function syntax contains less boilerplate and has the form `(arguments) -> body`,
whereas function application does not require parenthesis if there is more than one argument
(you can use them, though).
The following example shows how to write nested functions with more than one line in the body and
how function application binds tightly. It also shows the comment syntax, indentation rules, implicit
returns, string interpolation and a bit of functional programming.

    # Simple function definition
    add = (a, b) -> a + b

    # Function with a multi-line body
    curriedAdd = (a) ->
      # Indention matters!
      console.log parseInt a

      # Return a function
      (b) ->
        # Indention matters!
        # String interpolation with #{expr}
        console.log "b is: #{parseInt b}"
        # The last statement of a function body
        # is it's return value. But you can use
        # an explicit return, too.
        return a + b

    add 1, 2                 # yields 3
    add(1,2)                 # yields 3
    add 1, parseInt "2"      # yields 3
    add 1, parseInt("2")     # yields 3
    add parseInt("1"), 2     # yields 3
    add (parseInt "1"), 2    # yields 3
    add parseInt "1", 2      # not what you want! (add(parseInt("1", 2))

    curriedAdd(1)(2)         # yields 3
    curriedAdd(1) 2          # yields 3
    curriedAdd 1, 2          # not what you want! (curriedAdd(1,2))

    addThree = curriedAdd 3  # returns a function
    addThree 5               # yields 8
    addThree 8               # yields 11

    console.log [1,2,3,4].map (i) -> i + 1 # prints [2,3,4,5]
    console.log [1,2,3,4].map addThree     # prints [4,5,6,7]

    hello = -> console.log "hello"
    hello()       # prints hello
    hello         # not what you want (returns the function)
    hello "world" # prints hello (function ignores parameters)

The functions are translated to (an equivilant of) the following:

    function add(a, b) { return a + b; }

    function curriedAdd(a) {
      console.log(parseInt(a));
      return function(b) {
        console.log("b is: " + parseInt(b));
        return a + b;
      };
    }

Some of the function applications in JavaScript:

    console.log(add(1,2));
    console.log(curriedAdd(1)(2));
    var addThree = curriedAdd(3);
    console.log(addThree(4));
    console.log([1,2,3].map(function(i) { return i + 1 }));
    console.log([1,2,3].map(addThree));

#### RequireJS

RequireJS provides means to define and load JavaScript modules which sadly is not a build-in feature
of the language.
Writing a module is as simple as (using CoffeeScript syntax):

    define ->

      # The importer of the module will see
      # whatever you return here. In this
      # case an object containing two functions
      functionA: -> console.log "hello"
      functionB: -> console.log "world"

Using the path of the module file, you can now import it:

    require ["dummy"], (Dummy) ->
      # Say hello and world
      Dummy.functionA()
      Dummy.functionB()

To define the dependencies of a module use the following syntax:

    define ["dependencyA", "dependencyB"], (DepA, DepB) ->
      # Can access DepA and DepB here

Normally, RequireJS loads the modules from the server when they are needed the first time. However,
it is also possible to minify all modules into a single .js file using the `r.js` utility. The
`Makefile` in the `js/chart` directory takes care of this.

#### Twitter Flight
[Twitter's Flight](http://twitter.github.io/flight) is an event-driven frontend framework
which lets you define so-called components whose job it is to "take care" of a specific DOM element.
The only way these components can communicate is by triggering events.

Using RequireJS and Flight, a component is defined like this:

    define ->

      flight.component ->

        @hello = -> console.log "hello"

        @after "initialize", ->
          console.log "I'm assigned to the following element:"
          console.log @node  # DOM element
          console.log @$node # jQuery-wrapped element

          @on "sayHello", ->
            @hello()
            @$node.text "hello"
          @on "sayBye", ->
            @$node.fadeOut()
            @trigger "refresh"

This component listens to two events: "sayHello" and "sayBye". It also trigger a "refresh" event
after it received the latter. An event travel up the DOM elements until a component handles it.
Futhermore, you can send an event to a specific element which also carries data by using something
like: `@trigger "#content", "refresh", greeting: "hello"`.

Note: The symbol `@` is an abbreviation for the keyword `this` in CoffeeScript. Moreover you will
see something like `(param) => ...` in component code. This works just like an ordinary function
definition but keeps the `this` reference stable in the body. This is often used to call
component functions inside a callback.

    
## The Charts Frontend Implementation
[TODO]

